Description: Hyprpm: Support global plugins.
 Adds support for adding and enabling plugins provided by PPA.
Author: Constantin Piber <cp.piber@gmail.com>

Index: source/hyprpm/src/core/PluginManager.cpp
===================================================================
--- source.orig/hyprpm/src/core/PluginManager.cpp
+++ source/hyprpm/src/core/PluginManager.cpp
@@ -114,7 +114,9 @@ bool CPluginManager::createSafeDirectory
 bool CPluginManager::addNewPluginRepo(const std::string& url, const std::string& rev) {
     const auto HLVER = getHyprlandVersion();
 
-    if (!hasDeps()) {
+    const bool bIsGlobal = url.find('/') == std::string::npos && std::filesystem::exists(std::string{DATAROOTDIR "/hyprpm/"} + url);
+
+    if (!bIsGlobal && !hasDeps()) {
         std::println(stderr, "\n{}", failureString("Could not clone the plugin repository. Dependencies not satisfied. Hyprpm requires: cmake, meson, cpio, pkg-config"));
         return false;
     }
@@ -134,6 +136,13 @@ bool CPluginManager::addNewPluginRepo(co
         DataState::updateGlobalState(GLOBALSTATE);
     }
 
+    if (bIsGlobal)
+        std::cout << Colors::GREEN << "✔" << Colors::RESET << Colors::RED << " adding a new plugin repository " << Colors::RESET << "from global files " << DATAROOTDIR "/hyprpm/" << url << "\n  " << Colors::RED
+                  << "MAKE SURE" << Colors::RESET << " that you trust the authors. " << Colors::RED << "DO NOT" << Colors::RESET
+                  << " install random plugins without verifying the code and author.\n  "
+                  << "These files are provided by PPAs in your system.\n  "
+                  << "Are you sure? [Y/n] ";
+    else
     std::cout << Colors::GREEN << "✔" << Colors::RESET << Colors::RED << " adding a new plugin repository " << Colors::RESET << "from " << url << "\n  " << Colors::RED
               << "MAKE SURE" << Colors::RESET << " that you trust the authors. " << Colors::RED << "DO NOT" << Colors::RESET
               << " install random plugins without verifying the code and author.\n  "
@@ -147,6 +156,20 @@ bool CPluginManager::addNewPluginRepo(co
         return false;
     }
 
+    if (bIsGlobal) {
+        const auto PATH = DataState::getDataStatePath() + "/" + url;
+
+        std::filesystem::create_directories(PATH);
+        for (const auto& entry : std::filesystem::directory_iterator(std::string{DATAROOTDIR "/hyprpm/"} + url)) {
+            if (entry.path().filename() == "state.toml")
+                std::filesystem::copy_file(entry, PATH + "/state.toml");
+            else
+                std::filesystem::create_symlink(entry, PATH + "/" + entry.path().filename().string());
+        }
+        std::cout << Colors::GREEN << "✔" << Colors::RESET << " global repository added";
+        return true;
+    }
+
     CProgressBar progress;
     progress.m_iMaxSteps        = 5;
     progress.m_iSteps           = 0;
@@ -608,6 +631,49 @@ bool CPluginManager::updatePlugins(bool
         progress.m_szCurrentMessage = "Updating " + repo.name;
         progress.print();
 
+        // global repo
+        if (repo.url.empty()) {
+            auto              STATE = toml::parse_file(std::string{DATAROOTDIR "/hyprpm/"} + repo.name + "/state.toml");
+
+            const auto        NAME = STATE["repository"]["name"].value_or("");
+            const auto        URL  = STATE["repository"]["url"].value_or("");
+            const auto        REV  = STATE["repository"]["rev"].value_or("");
+            const auto        HASH = STATE["repository"]["hash"].value_or("");
+
+            SPluginRepository newrepo;
+            newrepo.hash = HASH;
+            newrepo.name = NAME;
+            newrepo.url  = URL;
+            newrepo.rev  = REV;
+
+            for (const auto& [key, val] : STATE) {
+                if (key == "repository")
+                    continue;
+
+                const auto ENABLED  = STATE[key]["enabled"].value_or(false);
+                const auto FAILED   = STATE[key]["failed"].value_or(false);
+                const auto FILENAME = STATE[key]["filename"].value_or("");
+
+                newrepo.plugins.push_back(SPlugin{std::string{key.str()}, FILENAME, ENABLED, FAILED});
+            }
+
+            DataState::removePluginRepo(repo.name);
+            const auto PATH = DataState::getDataStatePath() + "/" + newrepo.name;
+            std::filesystem::create_directories(PATH);
+            for (const auto& entry : std::filesystem::directory_iterator(std::string{DATAROOTDIR "/hyprpm/"} + newrepo.name)) {
+                if (entry.path().filename() == "state.toml")
+                    continue;
+                std::filesystem::create_symlink(entry, PATH + "/" + entry.path().filename().string());
+            }
+            for (auto& p : newrepo.plugins) {
+                const auto OLDPLUGINIT = std::find_if(repo.plugins.begin(), repo.plugins.end(), [&](const auto& other) { return other.name == p.name; });
+                p.enabled = OLDPLUGINIT != repo.plugins.end() ? OLDPLUGINIT->enabled : false;
+            }
+            DataState::addNewPluginRepo(newrepo);
+            progress.printMessageAbove(successString("updated {}", repo.name));
+            continue;
+        }
+
         progress.printMessageAbove(infoString("checking for updates for {}", repo.name));
 
         createSafeDirectory(m_szWorkingPluginDirectory);
Index: source/hyprpm/CMakeLists.txt
===================================================================
--- source.orig/hyprpm/CMakeLists.txt
+++ source/hyprpm/CMakeLists.txt
@@ -15,6 +15,8 @@ add_executable(hyprpm ${SRCFILES})
 
 target_link_libraries(hyprpm PUBLIC PkgConfig::hyprpm_deps)
 
+add_compile_definitions(DATAROOTDIR="${CMAKE_INSTALL_FULL_DATAROOTDIR}")
+
 # binary
 install(TARGETS hyprpm)
 
